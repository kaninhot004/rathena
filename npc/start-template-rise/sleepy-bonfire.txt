moc_akhet,190,248,5	script	กองไฟนิทรา	10252,{
	// Still warping
	if(isWarping)
	{
		end;
	}
	// Filling up Sleeping Pill
	FillUpSleepyPill();
	// Only party leader
	if(!is_party_leader())
	{
		mes "ท่านต้องเป็นหัวหน้า Party..";
		close;
	}
	// Cooldowning
	if(dreamCd > gettimetick(2))
	{
		mes "โปรดรอ " + (dreamCd - gettimetick(2)) + " วินาที..";
		close;
	}
	// Clear 0 player in busy map
	freeloop(1);
	for(.@i = getarraysize($busyMap$) - 1; .@i >= 0; .@i--)
	{
		if(getmapusers($busyMap$[.@i]) <= 0)
		{
			deletearray $busyMap$[.@i],1;
		}
	}
	freeloop(0);
	// Setup
	.@partyId = getcharid(1);
	getpartymember .@partyId,1;
	getpartymember .@partyId,2;
	.@partySize = $@partymembercount;
	partySize = .@partySize;
	.@online = 0;
	.@playDreamIndex = INT_MAX;
	freeloop(1);
	for(.@i = 0; .@i < .@partySize; .@i++)
	{
		if(!isloggedin($@partymemberaid[.@i],$@partymembercid[.@i]))
		{
			continue;
		}
		.@online++;
		if(!getvar(isSuitPicked,$@partymembercid[.@i]))
		{
			mes "มีสมาชิกใน Party ยังไม่ได้เลือกชุด..";
			close;
		}
		if(!getvar(isWishGranted,$@partymembercid[.@i]))
		{
			mes "มีสมาชิกใน Party ยังไม่เคยขอพร..";
			close;
		}
		.@dreamIndex = getvar(dreamIndex,$@partymembercid[.@i]);
		// Try to get lowest dream index
		if((.@dreamIndex < .@playDreamIndex) || (.@playDreamIndex != playDreamIndex))
		{
			.@playDreamIndex = .@dreamIndex;
			playDreamIndex = .@dreamIndex;
			isDreamSetup = 0;
			dreamBy$ = strcharinfo(0,$@partymembercid[.@i]);
		}
	}
	if(.@online <= 0)
	{
		mes "ไม่พบสมาชิกใน Party ที่ Online อยู่เลย..";
		close;
	}
	.@dreamLevelIndex = GetDreamLevelIndex(playDreamIndex);
	// One time setup
	if(!isDreamSetup)
	{
		// Monster Setup
		.@guaranteeMvp = $guaranteeMvp[.@dreamLevelIndex];
		mRankMin = $minimumRank[.@dreamLevelIndex];
		mRankMax = $maximumRank[.@dreamLevelIndex];
		.@monsterType = rand($monsterTypeMin[.@dreamLevelIndex],$monsterTypeMax[.@dreamLevelIndex]);
		deletearray monsterType[0],getarraysize(monsterType);
		.@fairLevel = $fairLevel[.@dreamLevelIndex];
		.@fairPlay = $fairPlay[.@dreamLevelIndex];
		for(.@i = 0; .@i < .@monsterType; .@i++)
		{
			setarray monsterType[.@i],$attackableMonsterIds[rand(getarraysize($attackableMonsterIds))];
			if(rand(100) <= .@fairPlay)
			{
				setarray monsterType[.@i],getd("$attackableMonsterTier" + .@fairLevel + "Ids[" + rand(getarraysize(getd("$attackableMonsterTier" + .@fairLevel + "Ids")))+ "]");
			}
		}
		if(.@guaranteeMvp > 0)
		{
			for(.@i = 0; .@i < getarraysize(.@guaranteeMvp); .@i++)
			{
				monsterType[.@i] = $mvpIds[rand(getarraysize($mvpIds))];
			}
		}
		for(.@i = 0; .@i < getarraysize(monsterType); .@i++)
		{
			if(inarray($mvpIds,monsterType[.@i]) >= 0)
			{
				.@mvpAmount++;
			}
		}
		isDreamSetup = 1;
	}
	mAmount = ($monsterAmount[.@dreamLevelIndex] / (1 + .@mvpAmount));
	mes "จะทำการเข้าสู่ชั้นความฝันที่ ^292fff" + playDreamIndex + "^000000 ของ ^292fff" + dreamBy$ + "^000000";
	mes "Monster จะ";
	mes " ^ff2929มี Rank " + mRankMin + "~" + mRankMax + "^000000";
	mes " ^ff2929Spawn " + mAmount + " ตัว^000000";
	mes " ^ff2929แตกต่างกัน " + getarraysize(monsterType) + " ชนิด^000000";
	freeloop(0);
	next;
	menu
	"เข้าสู่ความฝัน แบบ Monster ^17b217ตายแล้ว Spawn เรื่อย ๆ^000000",OnLargeSpawn
	,"เข้าสู่ความฝัน แบบ Monster ^ff2929Spawn เยอะมาก ๆ^000000",OnHugeSpawn
	,"เข้าสู่ความฝัน แบบ Monster ^17b217Spawn เท่าที่แจ้ง^000000",OnNormalSpawn
	,"ตั้งค่า เล่นชั้นต่อไปเรื่อย ๆ หากชนะ [" + (isContinuePlaying ? "ON" : "OFF") + "]",OnContinuePlaying
	,"ตั้งค่า Monster Spawn รอบตัว (Spawn รอบนึงจะไม่เกิน 30 ตัว ภายในระยะ 7x7 ช่อง) [" + (isSpawnAround ? "ON" : "OFF") + "]",OnSpawnAround
	,"ตั้งค่า ความเร็วในการเริ่มรอบ [" + (!roundSpeed ? "5" : roundSpeed) + " วินาที]",OnRoundSpeed
	;
OnContinuePlaying:
	isContinuePlaying = !isContinuePlaying;
	mes "ตั้งค่า เล่นชั้นต่อไปเรื่อย ๆ หากชนะ [" + (isContinuePlaying ? "ON" : "OFF")+ "]";
	close;
OnSpawnAround:
	isSpawnAround = !isSpawnAround;
	mes "ตั้งค่า Monster Spawn รอบตัว (Spawn รอบนึงจะไม่เกิน 30 ตัว ภายในระยะ 7x7 ช่อง) [" + (isSpawnAround ? "ON" : "OFF")+ "]";
	close;
OnRoundSpeed:
	input(roundSpeed);
	roundSpeed = cap_value(roundSpeed,1,5);
	mes "ตั้งค่า ความเร็วในการเริ่มรอบ [" + roundSpeed+ " วินาที]";
	close;
OnHugeSpawn:
	isLargeSpawn = 2;
	goto OnStartTalk;
OnLargeSpawn:
	isLargeSpawn = 1;
	goto OnStartTalk;
OnNormalSpawn:
	isLargeSpawn = 0;
OnStartTalk:
	freeloop(1);
	.@partyId = getcharid(1);
	getpartymember .@partyId,1;
	getpartymember .@partyId,2;
	.@partySize = $@partymembercount;
	if(.@partySize != partySize)
	{
		mes "สมาชิกใน Party มีการเปลี่ยนแปลง โปรดลองใหม่อีกครั้ง";
		close;
	}
	.@retry = 300;
	// Map Setup
	map$ = $maps$[rand(getarraysize($maps$))];
	while((inarray($busyMap$,map$) >= 0) && (.@retry > 0))
	{
		map$ = $maps$[rand(getarraysize($maps$))];
		.@retry--;
	}
	freeloop(0);
	if(.@retry <= 0)
	{
		mes "มีคนกำลังฝันอยู่เยอะเกินไป โปรดรอสักครู่..";
		close;
	}
	deletearray getd("$" + map$ + "MonsterType[0]"),getarraysize(getd("$" + map$ + "MonsterType"));
	for(.@i = 0; .@i < getarraysize(monsterType); .@i++)
	{
		set(getd("$" + map$ + "MonsterType[" + .@i + "]"),monsterType[.@i]);
	}
	set(getd("$" + map$ + "MonsterRankMin"),mRankMin);
	set(getd("$" + map$ + "MonsterRankMax"),mRankMax);
	set(getd("$" + map$ + "RemainingMonster"),mAmount);
	set(getd("$" + map$ + "Killed"),0);
	set(getd("$" + map$ + "Spawned"),0);
	set(getd("$" + map$ + "NIN"),0);
	// Additional settings
	set(getd("$" + map$ + "LargeSpawn"),isLargeSpawn);
	set(getd("$" + map$ + "SpawnAround"),isSpawnAround);
	set(getd("$" + map$ + "ContinuePlaying"),isContinuePlaying);
	setarray $busyMap$[getarraysize($busyMap$)],map$;
	// Set variables to everyone
	.@partyId = getcharid(1);
	getpartymember .@partyId,1;
	getpartymember .@partyId,2;
	.@partySize = $@partymembercount;
	.@cd = gettimetick(2) + 60;
	for(.@i = 0; .@i < .@partySize; .@i++)
	{
		if(!isloggedin($@partymemberaid[.@i],$@partymembercid[.@i]))
		{
			continue;
		}
		set(dreamCd,.@cd,$@partymembercid[.@i]);
		set(isPartyLeader,0,$@partymembercid[.@i]);
		set(playDreamIndex,playDreamIndex,$@partymembercid[.@i]);
		set(mRankMin,mRankMin,$@partymembercid[.@i]);
		set(mRankMax,mRankMax,$@partymembercid[.@i]);
		set(isDreamSetup,1,$@partymembercid[.@i]);
	}
	isPartyLeader = 1;
	isWarping = 1;
	// Wait 0.001s to warp
	addtimer 1,strnpcinfo(0) + "::OnWarpToDream";
	// Wait 5s to spawn
	.@roundSpeed = (roundSpeed > 0) ? (roundSpeed * 1000) : 5000;
	addtimer .@roundSpeed,strnpcinfo(0) + "::OnSpawn";
	// Set monster type to everyone
	.monsterType = getarraysize(monsterType);
	copyarray .monsterId[0],monsterType[0],.monsterType;
	addrid(2,0,.@partyId);
	deletearray monsterType[0],getarraysize(monsterType);
	for(.@i = 0; .@i < .monsterType; .@i++)
	{
		setarray monsterType[.@i],.monsterId[.@i];
	}
	end;
	
OnWarpToDream:
	isWarping = 0;
	.@partyId = getcharid(1);
	getpartymember .@partyId,1;
	getpartymember .@partyId,2;
	.@partySize = $@partymembercount;
	if(.@partySize != partySize)
	{
		mes "สมาชิกใน Party มีการเปลี่ยนแปลง โปรดลองใหม่อีกครั้ง";
		close;
	}
	// Warp party
	warpparty map$,0,0,.@partyId;
	killmonsterall map$;
	end;
	
OnSpawn:
	if(!playerattached())
	{
		end;
	}
	.@mapName$ = strcharinfo(3);
	// Map checking
	if(IsSafeMap())
	{
		end;
	}
	// Party member amount checking
	.@partyId = getcharid(1);
	getpartymember .@partyId,1;
	getpartymember .@partyId,2;
	.@partySize = $@partymembercount;
	if(.@partySize != partySize)
	{
		// Remove from busy map
		.@busyMapIndex = inarray($busyMap$,.@mapName$);
		if(.@busyMapIndex != -1)
		{
			deletearray $busyMap$[.@busyMapIndex],1;
		}
		addrid(1);
		isPartyAmountChange = 1;
		// Warp map
		warp "Save",0,0;
		end;
	}
	// Spawn monster
	freeloop(1);
	.@remainingMonster = getd("$" + .@mapName$ + "RemainingMonster");
	mapannounce .@mapName$,"เริ่ม ชั้นความฝันที่ " + playDreamIndex + " --- ศัตรูคงเหลือ " + .@remainingMonster + " ตัว",0;
	if(getd("$" + .@mapName$ + "LargeSpawn") == 2)
	{
		.@remainingMonster = 300;
	}
	if(getd("$" + .@mapName$ + "SpawnAround") == 1)
	{
		.@remainingMonster = cap_value(.@remainingMonster,0,30);
		// Get Player Cell
		getmapxy(.@mapName$,.@baseX,.@baseY);
		.@cellSize = 7;
	}
	else
	{
		// Get Free Cell
		getfreecell(.@mapName$,.@baseX,.@baseY);
		.@cellSize = 4;
	}
	for(.@i = 0; .@i < .@remainingMonster; .@i++)
	{
		.@maximumMonsterType = getarraysize(getd("$" + .@mapName$ + "MonsterType[" + .@i + "]"));
		if(.@maximumMonsterType <= 1)
		{
			.@monsterId = getd("$" + .@mapName$ + "MonsterType[0]");
		}
		else
		{
			.@monsterId = getd("$" + .@mapName$ + "MonsterType[" + rand(.@maximumMonsterType) + "]");
		}
		getfreecell(.@mapName$,.@spawnX,.@spawnY,.@baseX,.@baseY,.@cellSize,.@cellSize);
		monster .@mapName$,.@spawnX,.@spawnY,"--ja--",.@monsterId,1,strnpcinfo(0) + "::OnMonsterDead";
		setunitdata $@mobid[0],UMOB_RANK,rand(mRankMin,mRankMax);
		set(getd("$" + .@mapName$ + "Spawned"),getd("$" + .@mapName$ + "Spawned") + 1);
		// Limit to 300 per spawn
		if(.@i >= 299)
		{
			break;
		}
		if(getd("$" + .@mapName$ + "SpawnAround") <= 0)
		{
			// 40% Chance to get new spawn point 
			if(rand(100) < 40)
			{
				getfreecell(.@mapName$,.@baseX,.@baseY);
			}
		}
	}
	freeloop(0);
	end;
	
OnMonsterDead:
	if(!playerattached())
	{
		end;
	}
	.@mapName$ = strcharinfo(3);
	if(IsSafeMap())
	{
		end;
	}
	if((getcharid(1) <= 0) && isPartyLeader)
	{
		isWishGenerated = 0;
		dreamIndex = cap_value(dreamIndex - 1,0,1000);
		// Remove monster
		killmonsterall .@mapName$;
		// Remove from busy map
		.@busyMapIndex = inarray($busyMap$,.@mapName$);
		if(.@busyMapIndex != -1)
		{
			deletearray $busyMap$[.@busyMapIndex],1;
		}
		addrid(1);
		isPartyLeaderLeaveParty = 1;
		// Warp map
		warp "Save",0,0;
		end;
	}
	set(getd("$" + .@mapName$ + "Killed"),getd("$" + .@mapName$ + "Killed") + 1);
	.@remainingMonster = getd("$" + .@mapName$ + "RemainingMonster") - getd("$" + .@mapName$ + "Killed");
	if(.@remainingMonster > 0)
	{
		mapannounce .@mapName$,"ศัตรูคงเหลือ " + .@remainingMonster + " ตัว",0;
		.@remainingMonsterToSpawn = getd("$" + .@mapName$ + "RemainingMonster") - getd("$" + .@mapName$ + "Spawned");
		if(getd("$" + .@mapName$ + "LargeSpawn") > 0)
		{
			.@remainingMonsterToSpawn = 1;
		}
		if(.@remainingMonsterToSpawn > 0)
		{
			if(getd("$" + .@mapName$ + "SpawnAround") == 1)
			{
				// Get Player Cell
				getmapxy(.@unusedMapName$,.@baseX,.@baseY);
				.@cellSize = 7;
			}
			else
			{
				// Get Free Cell
				getfreecell(.@mapName$,.@baseX,.@baseY);
				.@cellSize = 4;
			}
			for(.@i = 0; .@i < .@remainingMonsterToSpawn; .@i++)
			{
				.@maximumMonsterType = getarraysize(getd("$" + .@mapName$ + "MonsterType[" + .@i + "]"));
				if(.@maximumMonsterType <= 1)
				{
					.@monsterId = getd("$" + .@mapName$ + "MonsterType[0]");
				}
				else
				{
					.@monsterId = getd("$" + .@mapName$ + "MonsterType[" + rand(.@maximumMonsterType) + "]");
				}
				getfreecell(.@mapName$,.@spawnX,.@spawnY,.@baseX,.@baseY,.@cellSize,.@cellSize);
				monster .@mapName$,.@spawnX,.@spawnY,"--ja--",.@monsterId,1,strnpcinfo(0) + "::OnMonsterDead";
				setunitdata $@mobid[0],UMOB_RANK,rand(getd("$" + .@mapName$ + "MonsterRankMin"),getd("$" + .@mapName$ + "MonsterRankMax"));
				set(getd("$" + .@mapName$ + "Spawned"),getd("$" + .@mapName$ + "Spawned") + 1);
				// 20% Chance to stop spawning more
				if(rand(100) < 20)
				{
					break;
				}
				if(getd("$" + .@mapName$ + "SpawnAround") <= 0)
				{
					// 40% Chance to get new spawn point 
					if(rand(100) < 40)
					{
						getfreecell(.@mapName$,.@baseX,.@baseY);
					}
				}
			}
		}
	}
	else
	{
		killmonsterall .@mapName$;
		.@rewardDreamIndex = cap_value(playDreamIndex + 1,0,1000);
		// Increase dream level to everyone (If possible)
		.@partyId = getcharid(1);
		getpartymember .@partyId,1;
		getpartymember .@partyId,2;
		.@partySize = $@partymembercount;
		for(.@i = 0; .@i < .@partySize; .@i++)
		{
			if(!isloggedin($@partymemberaid[.@i],$@partymembercid[.@i]))
			{
				continue;
			}
			if(strcharinfo(3,$@partymembercid[.@i]) != strcharinfo(3))
			{
				continue;
			}
			set(isDreamSetup,0,$@partymembercid[.@i]);
			set(dreamCd,0,$@partymembercid[.@i]);
			if(getvar(dreamIndex,$@partymembercid[.@i]) < .@rewardDreamIndex)
			{
				set(isWishGenerated,0,$@partymembercid[.@i]);
				set(dreamIndex,.@rewardDreamIndex,$@partymembercid[.@i]);
				set(isAnnounceInLobby,1,$@partymembercid[.@i]);
			}
		}
		if(getd("$" + .@mapName$ + "ContinuePlaying") <= 0)
		{
			// Remove from busy map
			.@busyMapIndex = inarray($busyMap$,.@mapName$);
			if(.@busyMapIndex != -1)
			{
				deletearray $busyMap$[.@busyMapIndex],1;
			}
			// Warp party
			warpparty $town$,0,0,.@partyId;
		}
		else
		{
			// ALWAYS COPY FROM ABOVE
			// ALWAYS COPY FROM ABOVE
			// ALWAYS COPY FROM ABOVE
			
			// Setup
			.@partyId = getcharid(1);
			getpartymember .@partyId,1;
			getpartymember .@partyId,2;
			.@partySize = $@partymembercount;
			partySize = .@partySize;
			.@online = 0;
			.@playDreamIndex = INT_MAX;
			freeloop(1);
			for(.@i = 0; .@i < .@partySize; .@i++)
			{
				if(!isloggedin($@partymemberaid[.@i],$@partymembercid[.@i]))
				{
					continue;
				}
				.@online++;
				if(!getvar(isSuitPicked,$@partymembercid[.@i]))
				{
					mes "มีสมาชิกใน Party ยังไม่ได้เลือกชุด..";
					close;
				}
				if(!getvar(isWishGranted,$@partymembercid[.@i]))
				{
					mes "มีสมาชิกใน Party ยังไม่เคยขอพร..";
					close;
				}
				.@dreamIndex = getvar(dreamIndex,$@partymembercid[.@i]);
				// Try to get lowest dream index
				if((.@dreamIndex < .@playDreamIndex) || (.@playDreamIndex != playDreamIndex))
				{
					.@playDreamIndex = .@dreamIndex;
					playDreamIndex = .@dreamIndex;
					isDreamSetup = 0;
					dreamBy$ = strcharinfo(0,$@partymembercid[.@i]);
				}
			}
			if(.@online <= 0)
			{
				mes "ไม่พบสมาชิกใน Party ที่ Online อยู่เลย..";
				close;
			}
			.@dreamLevelIndex = GetDreamLevelIndex(playDreamIndex);
			// One time setup
			if(!isDreamSetup)
			{
				// Monster Setup
				.@guaranteeMvp = $guaranteeMvp[.@dreamLevelIndex];
				mRankMin = $minimumRank[.@dreamLevelIndex];
				mRankMax = $maximumRank[.@dreamLevelIndex];
				.@monsterType = rand($monsterTypeMin[.@dreamLevelIndex],$monsterTypeMax[.@dreamLevelIndex]);
				deletearray monsterType[0],getarraysize(monsterType);
				.@fairLevel = $fairLevel[.@dreamLevelIndex];
				.@fairPlay = $fairPlay[.@dreamLevelIndex];
				for(.@i = 0; .@i < .@monsterType; .@i++)
				{
					setarray monsterType[.@i],$attackableMonsterIds[rand(getarraysize($attackableMonsterIds))];
					if(rand(100) <= .@fairPlay)
					{
						setarray monsterType[.@i],getd("$attackableMonsterTier" + .@fairLevel + "Ids[" + rand(getarraysize(getd("$attackableMonsterTier" + .@fairLevel + "Ids")))+ "]");
					}
				}
				if(.@guaranteeMvp > 0)
				{
					for(.@i = 0; .@i < getarraysize(.@guaranteeMvp); .@i++)
					{
						monsterType[.@i] = $mvpIds[rand(getarraysize($mvpIds))];
					}
				}
				for(.@i = 0; .@i < getarraysize(monsterType); .@i++)
				{
					if(inarray($mvpIds,monsterType[.@i]) >= 0)
					{
						.@mvpAmount++;
					}
				}
				isDreamSetup = 1;
			}
			mAmount = (($monsterAmount[.@dreamLevelIndex] * .@online) / (1 + .@mvpAmount));
			
			// Act like selected menu
			deletearray getd("$" + .@mapName$ + "MonsterType[0]"),getarraysize(getd("$" + .@mapName$ + "MonsterType"));
			for(.@i = 0; .@i < getarraysize(monsterType); .@i++)
			{
				set(getd("$" + .@mapName$ + "MonsterType[" + .@i + "]"),monsterType[.@i]);
			}
			set(getd("$" + .@mapName$ + "MonsterRankMin"),mRankMin);
			set(getd("$" + .@mapName$ + "MonsterRankMax"),mRankMax);
			set(getd("$" + .@mapName$ + "RemainingMonster"),mAmount);
			set(getd("$" + .@mapName$ + "Killed"),0);
			set(getd("$" + .@mapName$ + "Spawned"),0);
			
			// Set variables to everyone
			.@partyId = getcharid(1);
			getpartymember .@partyId,1;
			getpartymember .@partyId,2;
			.@partySize = $@partymembercount;
			.@cd = gettimetick(2) + 60;
			for(.@i = 0; .@i < .@partySize; .@i++)
			{
				if(!isloggedin($@partymemberaid[.@i],$@partymembercid[.@i]))
				{
					continue;
				}
				set(dreamCd,.@cd,$@partymembercid[.@i]);
				set(playDreamIndex,playDreamIndex,$@partymembercid[.@i]);
				set(mRankMin,mRankMin,$@partymembercid[.@i]);
				set(mRankMax,mRankMax,$@partymembercid[.@i]);
				set(isDreamSetup,1,$@partymembercid[.@i]);
			}
			// Wait 5s to spawn
			mapannounce .@mapName$,"ชั้นความฝันที่ " + playDreamIndex + " กำลังจะเริ่ม (หัวหน้า Party สามารถพิมพ์ @stop เพื่อหยุดเล่นชั้นต่อไปหากชนะได้)",0;
			.@roundSpeed = (roundSpeed > 0) ? (roundSpeed * 1000) : 5000;
			addtimer .@roundSpeed,strnpcinfo(0) + "::OnSpawn";
			// Set monster type to everyone
			.monsterType = getarraysize(monsterType);
			copyarray .monsterId[0],monsterType[0],.monsterType;
			addrid(2,0,.@partyId);
			// Filling up Sleeping Pill
			FillUpSleepyPill();
			deletearray monsterType[0],getarraysize(monsterType);
			for(.@i = 0; .@i < .monsterType; .@i++)
			{
				setarray monsterType[.@i],.monsterId[.@i];
			}
			
			// ALWAYS COPY FROM ABOVE
			// ALWAYS COPY FROM ABOVE
			// ALWAYS COPY FROM ABOVE
		}
		end;
	}
	end;

OnInit:
	deletearray $busyMap$[0],getarraysize($busyMap$);
	waitingroom strnpcinfo(1),0;
	end;
}
